public class StateAndReward {
	private static final int ANGLE_STATES = 10;
	private static final int HORIZ_STATES = 4;
	private static final int VERTI_STATES = 6;
	private static final double MIN_ANGLE = -2.0;
	private static final double MAX_ANGLE = 2.0;
	private static final double MIN_VX = -1.5;
	private static final double MAX_VX = 1.5;
	private static final int MIN_VY = -3;
	private static final int MAX_VY = 3;
	
	/* State discretization function for the angle controller */
	public static String getStateAngle(double angle, double vx, double vy) {

		/* TODO: IMPLEMENT THIS FUNCTION */

		// String state = "OneStateToRuleThemAll";
		// final double pi = Math.PI;
		
		// if (angle < pi/16 && angle >= -pi/16) {
		// 	state = "NORTH";
		// } else if (angle > pi/16 && angle <= pi/4) {
		// 	state = "NORTHEAST";
		// } else if (angle > pi/4 && angle <= pi/2) {
		// 	state = "EAST";
		// } else if (angle > pi/2 && angle <= -pi/2) {
		// 	state = "SOUTH";
		// } else if (angle > -pi/2 && angle <= -pi/4) {
		// 	state = "WEST";
		// } else { //(angle > -pi/4 && angle < -pi/16)
		// 	state = "NORTHWEST";
		// }

		String state = String.valueOf((double)discretize2(angle, ANGLE_STATES, MIN_ANGLE, MAX_ANGLE) / ANGLE_STATES);

		
//		System.out.println("dAngle: " + discretize2(angle, ANGLE_STATES, MIN_ANGLE, MAX_ANGLE) / ANGLE_STATES);
		System.out.println("STATE: " + state);

		return state;

		
	}

	/* Reward function for the angle controller */
	public static double getRewardAngle(double angle, double vx, double vy) {

		/* TODO: IMPLEMENT THIS FUNCTION */
		// double reward = 0;
		// final double pi = Math.PI;

		// if (angle < pi/16 && angle >= -pi/16) { // NORTH
		// 	reward = 1.0;
		// } else if ((angle > pi/4 && angle <= pi/2)
		// 			|| (angle > -pi/2 && angle <= -pi/4)) { // EAST || WEST
		// 	reward = 0.2;
		// } else if (angle > pi/2 && angle <= -pi/2) { // SOUTH
		// 	reward = -1.0;
		// } else { // NORTHEAST || NORTHWEST
		// 	reward = 0.7;
		// }
		double reward = ((double) discretize2(angle, ANGLE_STATES, MIN_ANGLE, MAX_ANGLE) / ANGLE_STATES);
		System.out.println("REWARD: " + reward);
		
		 return reward;
		
		// return (dAngle < MAX_ANGLE) ?
		// 	1 - (dAngle / MAX_ANGLE)
		// 	: 0;
	}

	/* State discretization function for the full hover controller */
	public static String getStateHover(double angle, double vx, double vy) {

		/* TODO: IMPLEMENT THIS FUNCTION */

		String state = "OneStateToRuleThemAll2";
		// final double epsilon = 0.05;
		
		// if (vx < 0 && vy < 0) {
		// 	state = "NORTHWEST";
		// } else if (vx > 0 && vy < 0) {
		// 	state = "NORTHEAST";
		// } else if (Math.abs(vx) < epsilon && vy < 0) {
		// 	state = "NORTH";
		// } else if (vx > 0 && Math.abs(vy) < epsilon) {
		// 	state = "EAST";
		// } else if (vx > 0 && vy > 0) {
		// 	state = "SOUTHEAST";
		// } else if (vx < 0 && vy > 0) {
		// 	state = "SOUTHWEST";
		// } else if (Math.abs(vx) < epsilon && vy > 0) {
		// 	state = "SOUTH";
		// } else if (vx < 0 && Math.abs(vy) < epsilon) {
		// 	state = "WEST";
		// }
		return state;

	}

	/* Reward function for the full hover controller */
	public static double getRewardHover(double angle, double vx, double vy) {

		/* TODO: IMPLEMENT THIS FUNCTION */
		
		double reward = 0;
		final double maxV1 = 0.1;
		final double maxV2 = 0.5;
		final double maxV3 = 1.5;

		if (Math.abs(vx) < maxV1 && Math.abs(vy) < maxV1) {
			reward = 1.0;
			System.out.println("REWARD!");
		} else if (Math.abs(vx) < maxV1 && Math.abs(vy) < maxV2) {
			reward = 0.7;
			System.out.println("REWARD!");
		} else if (Math.abs(vx) < maxV1 && Math.abs(vy) < maxV3) {
			reward = 0.2;
			System.out.println("REWARD!");
		} else {
			reward = -1;
		}


		// if( vx < 0.5 && vx > -0.5 && vy < 0 && vy > -1.2 ) {
		// 	reward += 1;
		// }else {
		// 	reward -= 0;
		// }


		return reward;
	}

	/** ///////////////////////////////////////////////////////////
	/* discretize() performs a uniform discretization of the
	/* value parameter.
	/* It returns an integer between 0 and nrValues-1.
	/* The min and max parameters are used to specify the interval
	/* for the discretization.
	/* If the value is lower than min, 0 is returned
	/* If the value is higher than min, nrValues-1 is returned
	/* otherwise a value between 1 and nrValues-2 is returned.
	/*
	/* Use discretize2() if you want a discretization method that does
	/* not handle values lower than min and higher than max.
	**/ ///////////////////////////////////////////////////////////
	public static int discretize(double value, int nrValues, double min, double max) {
		if (nrValues < 2) {
			return 0;
		}

		double diff = max - min;

		if (value < min) {
			return 0;
		}
		if (value > max) {
			return nrValues - 1;
		}

		double tempValue = value - min;
		double ratio = tempValue / diff;

		return (int) (ratio * (nrValues - 2)) + 1;
	}

	/** ///////////////////////////////////////////////////////////
	/* discretize2() performs a uniform discretization of the
	/* value parameter.
	/* It returns an integer between 0 and nrValues-1.
	/* The min and max parameters are used to specify the interval
	/* for the discretization.
	/* If the value is lower than min, 0 is returned
	/* If the value is higher than min, nrValues-1 is returned
	/* otherwise a value between 0 and nrValues-1 is returned.
	**/ ///////////////////////////////////////////////////////////
	public static int discretize2(double value, int nrValues, double min, double max) {
		double diff = max - min;

		if (value < min) {
			return 0;
		}
		if (value > max) {
			return nrValues - 1;
		}

		double tempValue = value - min;
		double ratio = tempValue / diff;

		return (int) (ratio * nrValues);
	}

}
